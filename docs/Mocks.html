<html><head>
	<META http-equiv="content-type" content="text/html; charset=utf-8">
	<title>dmocks.Mocks</title>
	</head><body>
	<h1>dmocks.Mocks</h1>
	<!-- Generated by Ddoc from Mocks.d -->
<br><br>
<dt><big>class <u>Mocker</u>;
</big></dt>
<dd>A class through which one creates mock objects and manages expected calls.
 
<br><br>

<dl><dt><big>void <u>Replay</u>();
</big></dt>
<dd>Stop setting up expected calls. Any calls after this point will
 be verified against the expectations set up before calling <u>Replay</u>.
          
<br><br>

</dd>
<dt><big>void <u>Record</u>();
</big></dt>
<dd><u>Record</u> method calls starting at this point. These calls are not
 checked against existing expectations; they create new expectations.
          
<br><br>

</dd>
<dt><big>void <u>Verify</u>();
</big></dt>
<dd>Check to see if there are any expected calls that haven't been
 matched with a real call. Throws an ExpectationViolationException
 if there are any outstanding expectations.
          
<br><br>

</dd>
<dt><big>T <u>Mock</u>(T : Object)();
</big></dt>
<dd>Get a mock object of the given type. 
<br><br>

</dd>
<dt><big>ExternalCall <u>Expect</u>(T)(T <i>ignored</i>);
</big></dt>
<dd>Only for non-void methods. Start an expected call; this returns
 an object that allows you to set various properties on the call,
 such as return value and number of repetitions.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"> Mocker m = <font color=blue>new</font> Mocker;
 Object o = m.Mock!(Object);
 m.<u>Expect</u>(o.toString).Return(<font color=red>"hello?"</font>);
</pre>
          
<br><br>

</dd>
<dt><big>ExternalCall <u>LastCall</u>();
</big></dt>
<dd>For void and non-void methods. Start an expected call; this returns
 an object that allows you to set various properties on the call,
 such as return value and number of repetitions.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"> Mocker m = <font color=blue>new</font> Mocker;
 Object o = m.Mock!(Object);
 o.toString;
 m.<u>LastCall</u>().Return(<font color=red>"hello?"</font>);
</pre>
          
<br><br>

</dd>
<dt><big>ExternalCall <u>Allowing</u>(T)(T <i>ignored</i>);
<br>ExternalCall <u><u>Allowing</u></u>(T = void)();
</big></dt>
<dd>Set up a result for a method, but without any backend accounting for it.
 Things where you want to allow this method to be called, but you aren't
 currently testing for it.
          
<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>ExternalCall</u>;
</big></dt>
<dd>An <u>ExternalCall</u> allows you to set up various options on a Call,
    such as return value, number of repetitions, and so forth.
<br><br>
<b>Examples:</b><br>
<pre class="d_code">    Mocker m = <font color=blue>new</font> Mocker;
    Object o = m.Mock!(Object);
    o.toString;
    m.LastCall().Return(<font color=red>"Are you still there?"</font>).Repeat(1, 12);
</pre>
 
<br><br>

<dl><dt><big>ExternalCall <u>Return</u>(T)(T <i>value</i>);
</big></dt>
<dd>Set the return value of call.
<br><br>
<b>Params:</b><br>
<table><tr><td>value</td>
<td>the value to return</td></tr>
</table><br>

</dd>
<dt><big>ExternalCall <u>IgnoreArguments</u>();
</big></dt>
<dd>The arguments for this call will be ignored.
      
<br><br>

</dd>
<dt><big>ExternalCall <u>Repeat</u>(int <i>min</i>, int <i>max</i>);
</big></dt>
<dd>This call must be repeated at least <i>min</i> times and can be repeated at
 most <i>max</i> times.
      
<br><br>

</dd>
<dt><big>ExternalCall <u>Repeat</u>(int <i>i</i>);
</big></dt>
<dd>This call must be repeated exactly <i>i</i> times.
      
<br><br>

</dd>
<dt><big>ExternalCall <u>RepeatAny</u>();
</big></dt>
<dd>This call can be repeated any number of times.
      
<br><br>

</dd>
<dt><big>ExternalCall <u>Do</u>(T,U...)(T delegate(U) <i>action</i>);
</big></dt>
<dd>When the method is executed (with matching arguments), execute the
 given delegate. The delegate's signature must match the signature
 of the called method. If it does not, an exception will be thrown.
 The called method will return whatever the given delegate returns.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"> m.Expect(myObj.myFunc(0, <font color=blue>null</font>, <font color=blue>null</font>, 'a')
     .IgnoreArguments()
     .<u>Do</u>((<font color=blue>int</font> i, string s, Object o, <font color=blue>char</font> c) { <font color=blue>return</font> -1; });
)
      
</pre>
<br><br>

<dt><big>ExternalCall <u>Throw</u>(Exception <i>e</i>);
</big></dt>
<dd>When the method is called, throw the given exception. If there are any
 actions specified (via the Do method), they will not be executed.
      
<br><br>

</dd>
<dt><big>ExternalCall <u>PassThrough</u>();
</big></dt>
<dd>Instead of returning or throwing a given value, pass the call through to
 the base class. This is dangerous -- the private fields of the class may
 not be set up properly, so only use this when the function does not depend
 on these fields. Things such as using Object's toHash and opEquals when your
 class doesn't override them and you use associative arrays.
      
<br><br>

</dd>
</dd>
</dl>
</dd>

	<hr><small>Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. </small>
	</body></html>
